# -*- coding: utf-8 -*-
"""Laboratório Python - eDAS003.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P2Ao5k5a3p13pg2WmBOl7XEnd4nL7MvM
"""
# %%
import pandas as pd
import matplotlib as plt
import numpy as np
#Importa os modelos da biblioteca scikit learn: 
from sklearn.linear_model import LogisticRegression 
from sklearn.model_selection import KFold 
from sklearn.ensemble import RandomForestClassifier 
from sklearn.tree import DecisionTreeClassifier, export_graphviz 
from sklearn import metrics

# %%
df = pd.read_csv("./ArquivoTreino.csv", sep = ',')

"""#ANÁLISE EXPLORATÓRIA DOS DADOS

"""
# %%
df.head(10)

df.describe()

df['Property_Area'].value_counts()

df['Education'].value_counts()

df['Gender'].value_counts()

df['ApplicantIncome'].hist(bins = 50)

df['LoanAmount'].hist(bins = 50)

df.boxplot('LoanAmount')

temp1 = df['Credit_History'].value_counts(ascending=True)
temp2 = df.pivot_table(values='Loan_Status',index=['Credit_History'],aggfunc=lambda x: x.map({'Y':1,'N':0}).mean())
print('Frequency Table for Credit History:')
print(temp1)
print('\nProbability of getting loan for each Credit History class:')
print(temp2)
# %%
df[df['Credit_History']==1]['Loan_Status'].value_counts()

x = 378/475
print(x)
# %%
import matplotlib.pyplot as plt
fig = plt.figure(figsize=(8,4))
ax1 = fig.add_subplot(121)
ax1.set_xlabel('Histórico de Crédito') 
ax1.set_ylabel('Contagem de Clientes') 
ax1.set_title('Clientes por Histórico') 
temp1.plot(kind='bar') 
ax2 = fig.add_subplot(122) 
ax2.set_xlabel('Histórico de Crédito') 
ax2.set_ylabel('Probabilidade de Empréstimo') 
ax2.set_title('Probabilidade de Empréstimo por Histórico') 
temp1.plot(kind = 'bar')

temp3 = pd.crosstab(df['Credit_History'], df['Loan_Status']) 
temp3.plot(kind='bar', stacked=True, color=['red','blue'], grid=False)
plt.title("Loan Status por Histórico de Crédito")
# %%
temp4 = pd.crosstab(df['Education'], df['Loan_Status']) 
temp4.plot(kind='bar', stacked=True, color=['red','blue'], grid=False)
plt.title("Loan Status por Educação")
# %%
temp5 = pd.crosstab(df['Married'], df['Loan_Status']) 
temp5.plot(kind='bar', stacked=True, color=['red','blue'], grid=False)
plt.title("Loan Status por Estado Civil")

temp6 = pd.pivot_table(df,index=['Credit_History', 'Married'], columns = 'Loan_Status', aggfunc = 'count')
temp6['Loan_ID'].plot(kind='bar', stacked=True, color=['red','blue'], grid=False)

temp6['Loan_ID'].head()
# %%
df['TotalIncome'] = df['ApplicantIncome'] + df['CoapplicantIncome']

df.boxplot('TotalIncome')
# %%
"""#ANÁLISE DE VALORES FALTANTES"""

df.apply(lambda x: sum(x.isnull()),axis=0)

df.boxplot(column='LoanAmount')

plt.figure(figsize = (12,10))
df.boxplot(column='LoanAmount', by=['Education','Self_Employed'])

plt.xticks(rotation=45, ha='right')
plt.title("Boxplot Distribution of Loan Amount", pad = 40)
# %%
#Porcentage of missing values in Self_Employed, Education has 0 missing values
(1 - df['Self_Employed'].count()/len(df['Self_Employed']))*100

#86% of value is No
df['Self_Employed'].value_counts()

#Replacing the missing values in Self_Employed to No
df['Self_Employed'].fillna('No',inplace=True)

table = df.pivot_table(values='LoanAmount', index='Self_Employed' ,columns='Education', aggfunc=np.median) 
table
# %%
# Define a função que retorna o valor da tabela pivot 
def fage(x): 
  return table.loc[x['Self_Employed'],x['Education']]

# Substitui valores faltantes 
df['LoanAmount'].fillna(df[df['LoanAmount'].isnull()].apply(fage, axis=1), inplace=True)

"""#Tratando Valores Extremos

"""

df['LoanAmount'].hist(bins=20)

#Colocando em escala logoratimica para reduzir os efeitos dos outliers.
df['LoanAmount_log'] = np.log(df['LoanAmount']) 
df['LoanAmount_log'].hist(bins=20)

df['TotalIncome'].hist(bins=20)

df['TotalIncome_log'] = np.log(df['TotalIncome']) 
df['TotalIncome_log'].hist(bins=20)
# %%
"""#TRATANDO VALORES FALTANTES 2"""

df.info()

for i in df.columns:
   if (df[i].count() < 614):
    print(i)

lst = []
for i in df.columns:
   if (df[i].count() < 614) & (df[i].dtypes == 'O'):
    lst.append(i)
lst

print("missing ", len(df['Gender']) - df['Gender'].count(),  "data")
# %%
df['Gender'].value_counts()

#Replacing the missing values in Gender to Male
df['Gender'].fillna('Male',inplace=True)
# %%
df['Married'].value_counts()

print("missing ", len(df['Married']) - df['Married'].count(),  "data")

#Replacing the missing values in Married to Yes
df['Married'].fillna('Yes',inplace=True)
# %%
df['Dependents'].value_counts()

print("missing ", len(df['Dependents']) - df['Dependents'].count(),  "data")

df['Dependents'].fillna('0',inplace=True)
# %%
df['Loan_Amount_Term'].value_counts()

print("missing ", len(df['Loan_Amount_Term']) - df['Loan_Amount_Term'].count(),  "data")

df['Loan_Amount_Term'].fillna(360,inplace=True)
# %%
df['Credit_History'].value_counts()

# Por ter muitos dados faltantes para essa coluna, comparei com a coluna do status do emprestimo para decidir qual valor a ser substituido. Caso o emprestimo tenha sido aprovado -> 1 ; ao contrario 0.
print("missing ", len(df['Credit_History']) - df['Credit_History'].count(),  "data")

x = df[ (df['Loan_Status'] == 'N') & df['Credit_History'].isnull()]['Credit_History']

for i in x.index:
  df.loc[i, 'Credit_History'] = 0
  #print(i)

print("missing ", len(df['Credit_History']) - df['Credit_History'].count(),  "data")
# %%
y = df[ (df['Loan_Status'] == 'Y') & df['Credit_History'].isnull()]['Credit_History']

for i in y.index:
  df.loc[i, 'Credit_History'] = 1
  #print(i)

print("missing ", len(df['Credit_History']) - df['Credit_History'].count(),  "data")

df['PossiblePayment'] = (df['LoanAmount']/df['TotalIncome'])*100


import seaborn as sns; sns.set(style="white", color_codes=True)
sns.boxplot(x = 'Loan_Status', y = 'PossiblePayment', hue = 'Loan_Status',data = df)

"""#Construindo Machine Learning Model"""

df.info()

df.dtypes
# %%
from sklearn.preprocessing import LabelEncoder 
var_mod =['Gender','Married','Dependents','Education','Self_Employed','Property_Area','Loan_Status'] 
le = LabelEncoder() 
for i in var_mod: df[i] = le.fit_transform(df[i]) 
df.dtypes


# %%
#Função para fazer um modelo de classificação para avaliar performance 
def classification_model(model, data, predictors, outcome): 
#Ajusta o modelo: 
  model.fit(data[predictors],data[outcome]) 
#Faz previsões nos dados de treino: 
  predictions = model.predict(data[predictors]) 
#Mostra a acurácia 
  accuracy = metrics.accuracy_score(predictions,data[outcome]) 
  print("Acurácia : %s" % "{0:.3%}".format(accuracy)) 
  #Realiza validação cruzada k-fold com 5 folds 
  kf = KFold(5,shuffle=False) 
  error = [] 
  for train, test in kf.split(data): 
    # Filtra dados de treino 
    train_predictors = (data[predictors].iloc[train,:]) 
    # O alvo que estamos usando para treinar o algoritmo 
    train_target = data[outcome].iloc[train] 
    # Treinando o algoritmo com previsores e alvo 
    model.fit(train_predictors, train_target) 
    #Grava erros de cada loop de validação cruzada 
    error.append(model.score(data[predictors].iloc[test,:], data[outcome].iloc[test]))
    print("Score da Validação Cruzada : %s" % "{0:.3%}".format(np.mean(error))) 
    #Acerta de novo o modelo para que possa se referir fora da função 
    model.fit(data[predictors],data[outcome])
    return model

# %%
#Random Forest
outcome_var = 'Loan_Status' 
model = RandomForestClassifier(n_estimators=100) 
predictor_var = ['Gender', 'Married', 'Dependents', 'Education', 'Self_Employed', 'Loan_Amount_Term', 'Credit_History', 'Property_Area', 'LoanAmount_log','TotalIncome_log','PossiblePayment'] 
classification_model(model, df,predictor_var,outcome_var)

#Matriz de importancia do modelo
#Criar uma série: 
featimp = pd.Series(model.feature_importances_, index=predictor_var).sort_values(ascending=False) 
print(featimp)

model_randomforest = RandomForestClassifier(n_estimators=25, min_samples_split=25, max_depth=7, max_features=1) 
predictor_var = ['TotalIncome','LoanAmount','Credit_History','Property_Area'] 
model_randon_forest_final = classification_model(model_randomforest, df,predictor_var,outcome_var)

#PREVENDO COM VALORES TESTES:
predictions_teste = pd.DataFrame([{"TotalIncome": 1000,
                     "LoanAmount": 150,
                     "Credit_History": 1,
                     "Property_Area": 2}])

print(model_randon_forest_final.predict(pd.DataFrame(predictions_teste))[0])
# %%
# Salvando os modelos
import pickle
import os
if not os.path.exists('models'):
  os.mkdir('models')

#salvando o random forest classifier
with open("fast_api_folder/ML_models/randomforestclassifier.pkl","wb") as file:
  pickle.dump(model_randon_forest_final,file)

# %%
# Carregando Pickle file
with open("fast_api_folder/ML_models/randomforestclassifier.pkl","rb") as file:
  pickle_model = pickle.load(file)
# %%
#PREVENDO O MODELO PICKLE COM VALORES TESTES:
# predictions_teste = pd.DataFrame([{"TotalIncome": 1500,
#                      "LoanAmount": 150,
#                      "Credit_History": 1,
#                      "Property_Area": 2}])
predictions_teste = pd.DataFrame([{"TotalIncome": 1500,
                     "LoanAmount": 150,
                     "Credit_History": 1,
                     "Property_Area": 2}])

print(pickle_model.predict(predictions_teste))

# %%
